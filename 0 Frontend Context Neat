Let's convert this to TypeScript and add support for multiple providers on specific routes. With TypeScript, we can define types for the providers, conditions, and the overall `ProviderComposer` component.

To handle multiple providers per path, we can update the `providers` array to accept an array of `provider` functions for each condition, wrapping `children` in each applicable provider.

Hereâ€™s how to do it:

### 1. Update `ProviderComposer` to TypeScript with Multiple Providers per Path

```typescript
// src/components/ProviderComposer.tsx
import { ReactNode } from 'react';
import { CounterStoreProvider } from '@/providers/counter-store-provider';
import { AnotherStoreProvider } from '@/providers/another-store-provider';

// Define type for provider components
type ProviderComponent = ({ children }: { children: ReactNode }) => JSX.Element;

// Define type for each condition entry
interface ProviderCondition {
  providers: ProviderComponent[]; // Accepts multiple providers
  condition: (pathname: string) => boolean;
}

// Define the list of providers with conditions
const providers: ProviderCondition[] = [
  {
    providers: [CounterStoreProvider],
    condition: (pathname) => pathname.startsWith('/counter-page'),
  },
  {
    providers: [AnotherStoreProvider],
    condition: (pathname) => pathname.startsWith('/another-page'),
  },
  {
    providers: [CounterStoreProvider, AnotherStoreProvider],
    condition: (pathname) => pathname.startsWith('/multi-provider-page'),
  },
  // Add more provider configurations as needed
];

// Define the ProviderComposer component
interface ProviderComposerProps {
  children: ReactNode;
  pathname: string;
}

export const ProviderComposer = ({ children, pathname }: ProviderComposerProps) => {
  return providers.reduce((acc, { providers, condition }) => {
    // Wrap children in each provider for matching conditions
    return condition(pathname)
      ? providers.reduceRight((wrapped, Provider) => <Provider>{wrapped}</Provider>, acc)
      : acc;
  }, children);
};
```

### Explanation of Changes

1. **Type Definitions**:
   - `ProviderComponent`: A type representing any provider component, expecting `children` as props.
   - `ProviderCondition`: Specifies an array of `providers` (for multiple providers per path) and a `condition` function to evaluate the pathname.

2. **Updated `providers` Array**:
   - Each entry now has a `providers` array, allowing multiple providers for each condition.

3. **Nested `reduceRight` for Wrapping Multiple Providers**:
   - `reduceRight` iterates through the `providers` array in reverse to wrap `acc` (the children) in each provider if the condition matches. This allows multiple providers to wrap around `children` sequentially.

### 2. Use `ProviderComposer` in `_app.tsx`

```typescript
// src/pages/_app.tsx
import { AppProps } from 'next/app';
import { ProviderComposer } from '@/components/ProviderComposer';

function MyApp({ Component, pageProps, router }: AppProps) {
  return (
    <ProviderComposer pathname={router.pathname}>
      <Component {...pageProps} />
    </ProviderComposer>
  );
}

export default MyApp;
```

### Benefits of This Setup

- **Flexibility**: Easily add multiple providers to a single path by including them in the `providers` array.
- **Type Safety**: TypeScript definitions ensure each provider meets the expected structure.
- **Readability**: Keeping the provider conditions organized in a single array makes it easy to manage and extend.

This solution is flexible, type-safe, and scales well when you need to apply multiple providers conditionally based on the route.
