If you have multiple conditions for wrapping pages in providers, you can still use a conditional setup in `_app.js` while keeping it organized and clean. Here’s a structured approach using an array of conditions and a helper function to apply providers only to specific pages:

### Approach: Use a `ProviderComposer` with Multiple Conditions

1. **Define Conditions in an Array**: Create an array of conditions, each specifying which provider to wrap around the page based on the route. This keeps all conditions in one place, making it easy to add or modify.

2. **Create a `ProviderComposer` Component**: This component iterates over the array of providers and applies each one conditionally.

3. **Use the `ProviderComposer` in `_app.js`**: Wrap `Component` with `ProviderComposer` to apply only the necessary providers based on the current route.

Here’s how this would look in code:

### 1. Define the `ProviderComposer`

```javascript
// src/components/ProviderComposer.js
import { CounterStoreProvider } from '@/providers/counter-store-provider';
import { AnotherStoreProvider } from '@/providers/another-store-provider';

const providers = [
  {
    provider: CounterStoreProvider,
    condition: (pathname) => pathname.startsWith('/counter-page'),
  },
  {
    provider: AnotherStoreProvider,
    condition: (pathname) => pathname.startsWith('/another-page'),
  },
  // Add more providers and conditions as needed
];

export const ProviderComposer = ({ children, pathname }) => {
  return providers.reduce((acc, { provider: Provider, condition }) => {
    return condition(pathname) ? <Provider>{acc}</Provider> : acc;
  }, children);
};
```

In this setup:
- `providers` is an array where each entry includes a `provider` and a `condition` function.
- The `condition` function checks the current `pathname` and decides if the `provider` should wrap the children.
- `reduce` applies each provider that meets its condition to the `children`, nesting them as needed.

### 2. Apply `ProviderComposer` in `_app.js`

```javascript
// src/pages/_app.js
import { ProviderComposer } from '@/components/ProviderComposer';

function MyApp({ Component, pageProps, router }) {
  return (
    <ProviderComposer pathname={router.pathname}>
      <Component {...pageProps} />
    </ProviderComposer>
  );
}

export default MyApp;
```

### Benefits of This Approach
- **Neat and Scalable**: You keep all conditions in a single array, making it easy to see which providers apply to which routes.
- **Easy to Modify**: Adding or removing conditions is straightforward—just update the `providers` array.
- **Avoids Multiple Wrappings**: Only the necessary providers wrap each page, reducing overhead and preventing redundant calls.

This setup keeps your code organized and allows for easy scaling as you add more conditions or providers. It’s also flexible if you later want to add more complex conditions or different providers for different parts of the app.
