type Primitive = string | number | boolean | null | undefined | bigint | symbol;
type Cleanable = Primitive | Date | Cleanable[] | { [key: string]: Cleanable };

export const cleanValues = (value: Cleanable): Cleanable => {
  // Define what is considered "empty"
  const isEmpty = (val: any): boolean => {
    if (val === undefined || val === null) return true; // Null or undefined
    if (typeof val === 'string' && val.trim() === '') return true; // Empty strings
    if (typeof val === 'number' && isNaN(val)) return true; // NaN
    if (Array.isArray(val) && val.length === 0) return true; // Empty arrays
    if (
      typeof val === 'object' &&
      !(val instanceof Date) &&
      val !== null &&
      Object.keys(val).length === 0
    ) {
      return true; // Empty objects (not including Dates)
    }
    return false; // All other cases
  };

  // Clean values recursively
  if (Array.isArray(value)) {
    return value
      .filter((item) => !isEmpty(item))
      .map((item) => cleanValues(item));
  } else if (typeof value === 'object' && value !== null) {
    if (value instanceof Date) {
      return isNaN(value.getTime()) ? undefined : value; // Keep valid dates
    }
    if (typeof value === 'bigint' || typeof value === 'symbol') {
      return value; // Preserve BigInt and Symbol
    }
    return Object.fromEntries(
      Object.entries(value)
        .map(([key, val]) => [key, cleanValues(val)])
        .filter(([_, val]) => !isEmpty(val)) // Remove empty key-value pairs
    );
  } else if (typeof value === 'string') {
    return value.trim() === '' ? undefined : value.trim(); // Trim and clean strings
  } else if (typeof value === 'number' || typeof value === 'boolean') {
    return value; // Keep valid numbers and booleans
  }

  // Return all other valid primitive values
  return value !== null && value !== undefined ? value : undefined;
};
